<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exercise # Adapt other patterns from the book of shaders (refer also to the shadertoy collection) and map them as textures onto other 3D shapes.
Procedural Texturing # 1. Introducción
La texturización procedural es una técnica revolucionaria en la creación de contenido digital que utiliza algoritmos y reglas matemáticas para generar texturas y patrones complejos en tiempo real. A diferencia de los métodos tradicionales, esta técnica automatizada permite crear texturas detalladas, realistas y personalizables de manera eficiente y escalable."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Procedural Texturing"><meta property="og:description" content="Exercise # Adapt other patterns from the book of shaders (refer also to the shadertoy collection) and map them as textures onto other 3D shapes.
Procedural Texturing # 1. Introducción
La texturización procedural es una técnica revolucionaria en la creación de contenido digital que utiliza algoritmos y reglas matemáticas para generar texturas y patrones complejos en tiempo real. A diferencia de los métodos tradicionales, esta técnica automatizada permite crear texturas detalladas, realistas y personalizables de manera eficiente y escalable."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcomputing.github.io/showcase/docs/Shaders/ProceduralTexturing/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-06-18T01:42:27-05:00"><title>Procedural Texturing | Visual Computing 2023-1</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Visual Computing 2023-1</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-7e4921a1bef13fc49e19193dc1bfdc8f class=toggle>
<label for=section-7e4921a1bef13fc49e19193dc1bfdc8f class="flex justify-between"><a href=/showcase/docs/members/>Members</a></label><ul><li><a href=/showcase/docs/members/Adrian/>Adrian</a></li><li><a href=/showcase/docs/members/Jaime/>Jaime</a></li><li><a href=/showcase/docs/members/Rodrigo/>Rodrigo</a></li></ul></li><li class=book-section-flat><a href=/showcase/docs/Shaders/>Shaders</a><ul><li><a href=/showcase/docs/Shaders/coloring/>Coloring</a></li><li><a href=/showcase/docs/Shaders/posteffects/>Post Effects</a></li><li><a href=/showcase/docs/Shaders/test/>Test</a></li><li><a href=/showcase/docs/Shaders/Texturing/>Texturing</a></li><li><a href=/showcase/docs/Shaders/ImageProcessing/>Image Processing</a></li><li><a href=/showcase/docs/Shaders/ProceduralTexturing/ class=active>Procedural Texturing</a></li><li><a href=/showcase/docs/Shaders/SpatialCoherence/>Spatial Coherence</a></li><li><a href=/showcase/docs/Shaders/Photomosaic/>Photomosaic</a></li></ul></li><li class=book-section-flat><a href=/showcase/docs/Transformations/>Transformations</a><ul><li><a href=/showcase/docs/Transformations/Texture-and-Lighting/>Texture and Lighting</a></li></ul></li><li class=book-section-flat><a href=/showcase/docs/Visual-Illusions/>Visual Illusions</a><ul><li><input type=checkbox id=section-99e4a0d55300f831d740177d881e77f4 class=toggle>
<label for=section-99e4a0d55300f831d740177d881e77f4 class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Coloring/>Coloring</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Coloring/Color-blindness/>Color Blindness</a></li></ul></li><li><input type=checkbox id=section-bd03a1ba8998ae8c9df2b933d511e416 class=toggle>
<label for=section-bd03a1ba8998ae8c9df2b933d511e416 class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Mach-Bands/>Mach Bands</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Mach-Bands/Terrain-with-Perlin-noise/>Terrain With Perlin Noise</a></li></ul></li><li><input type=checkbox id=section-7a7081fda5df7dbf85b6d879015de52b class=toggle>
<label for=section-7a7081fda5df7dbf85b6d879015de52b class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Masking/>Masking</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Masking/Visual-masking/>Visual Masking</a></li><li><a href=/showcase/docs/Visual-Illusions/Masking/Convolution-masks/>Convolution Masks</a></li></ul></li><li><input type=checkbox id=section-8f4e9ca131433d238729d21435de5a65 class=toggle>
<label for=section-8f4e9ca131433d238729d21435de5a65 class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Spatial-Coherence/>Spatial Coherence</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Spatial-Coherence/Pixelator-demo/>Pixelator Demo</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Procedural Texturing</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#exercise>Exercise</a></li><li><a href=#procedural-texturing>Procedural Texturing</a><ul><li><a href=#controles>Controles</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=exercise>Exercise
<a class=anchor href=#exercise>#</a></h2><p>Adapt other patterns from the book of shaders (refer also to the shadertoy collection) and map them as textures onto other 3D shapes.</p><h2 id=procedural-texturing>Procedural Texturing
<a class=anchor href=#procedural-texturing>#</a></h2><p><strong>1. Introducción</strong></p><p>La texturización procedural es una técnica revolucionaria en la creación de contenido digital que utiliza algoritmos y reglas matemáticas para generar texturas y patrones complejos en tiempo real. A diferencia de los métodos tradicionales, esta técnica automatizada permite crear texturas detalladas, realistas y personalizables de manera eficiente y escalable. Es ampliamente utilizada en la industria del entretenimiento para crear mundos virtuales convincentes en videojuegos, películas y animaciones. La texturización procedural ofrece eficiencia, escalabilidad, variabilidad y control creativo, impulsando la creación de experiencias visuales asombrosas en diversas industrias.</p><p><strong>2. Antecedentes y trabajo previo</strong></p><p>El concepto de texturización procedural tiene sus raíces en la década de 1970, cuando los investigadores comenzaron a explorar técnicas computacionales para la generación automática de texturas. Uno de los primeros trabajos destacados en este campo fue el desarrollado por Ken Perlin en 1983, conocido como el ruido de Perlin. Este algoritmo proporcionaba una forma eficiente de generar texturas orgánicas y naturales, y sigue siendo ampliamente utilizado en la industria del cine y los videojuegos.</p><p>A lo largo de los años, diversos investigadores y profesionales han contribuido al avance de la texturización procedural. Michael F. Cohen, John R. Wallace y David H. Salesin presentaron un enfoque basado en el análisis de texturas llamado &ldquo;Texture Synthesis on Surfaces&rdquo; en 1992, que permitía la creación de texturas realistas mediante la extracción de características y la síntesis procedural.</p><p>Otro hito importante en la texturización procedural se produjo en 1999, cuando Eric Lengyel introdujo los mapas de ruido llamados &ldquo;Simplex Noise&rdquo;, que son una mejora del ruido de Perlin y ofrecen resultados más suaves y detallados.</p><p>Con el tiempo, la texturización procedural se ha convertido en una disciplina activa de investigación y desarrollo, con la aparición de numerosos métodos y técnicas. Algunas áreas de estudio incluyen la generación de texturas procedurales basadas en fractales, la simulación de materiales realistas como madera, metal y piel, y la aplicación de principios físicos para lograr resultados más precisos.</p><p>En la industria del entretenimiento, la texturización procedural ha sido ampliamente adoptada para la creación de mundos virtuales en videojuegos, películas y animaciones. Herramientas como Substance Designer y Houdini permiten a los artistas y desarrolladores crear y manipular texturas procedurales de manera intuitiva y eficiente.</p><p>En resumen, el desarrollo de la texturización procedural ha sido impulsado por investigadores y profesionales a lo largo de las décadas, con importantes avances en algoritmos y técnicas. Esta área de estudio continúa evolucionando y desempeña un papel fundamental en la generación de contenido digital de alta calidad en diversas industrias.</p><p><strong>3. Solución</strong></p><p>En este ejercicio, se implementaron dos patrones. Uno tomado de <a href="https://thebookofshaders.com/10/?lan=es">The Book of Shaders: Random</a> llamado Mosaic y otro tomado de <a href=https://www.shadertoy.com/view/mds3DX>generative art deco 4 (Shadertoy)</a> y que aplica el concepto de <a href=https://en.wikipedia.org/wiki/Chromatic_aberration>Chromatic aberration</a>.</p><p>Por defecto se mostrará este segundo shader sobre un conjunto de conos generados aleatoriamente y que se mueven cíclicamente por el espacio (mod 400) mientras rotan.</p><p>Si el usuario selecciona mosaic del selector de shaders, los objetos se transforman en esferas y se aplica la textura procedimental mosaic.</p><h3 id=controles>Controles
<a class=anchor href=#controles>#</a></h3><ul><li><strong>Select</strong>: selecciona el shader de textura procedimental que desea visualizar</li></ul><iframe id=protexturing style=width:550px;height:550px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js></script>
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
             <script src=https://cdn.jsdelivr.net/gh/freshfork/p5.EasyCam@1.2.1/p5.easycam.js></script> 
            
            
            
            <script src=/showcase/sketches/shaders/ProceduralTexturing/protexturing.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe>
<details><summary>Sketch Code</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>angle</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>positions</span> <span style=color:#f92672>=</span> []; <span style=color:#75715e>// will contain objects 3D positions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>easycam</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>P</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>pg</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>cabberShader</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>mosaicShader</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>texselect</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tex</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>preload</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cabberShader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>readShader</span>(<span style=color:#e6db74>&#39;/VisualComputing/docs/Shaders/fragments/cabber.frag&#39;</span>, { <span style=color:#a6e22e>matrices</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Tree</span>.<span style=color:#a6e22e>NONE</span>, <span style=color:#a6e22e>varyings</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Tree</span>.<span style=color:#a6e22e>NONE</span> });
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mosaicShader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>readShader</span>(<span style=color:#e6db74>&#39;/VisualComputing/docs/Shaders/fragments/mosaic.frag&#39;</span>, { <span style=color:#a6e22e>matrices</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Tree</span>.<span style=color:#a6e22e>NONE</span>, <span style=color:#a6e22e>varyings</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Tree</span>.<span style=color:#a6e22e>NONE</span> });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>500</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createGraphics</span>(<span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>400</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>textureMode</span>(<span style=color:#a6e22e>NORMAL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noStroke</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>noStroke</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>textureMode</span>(<span style=color:#a6e22e>NORMAL</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>easycam</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createEasyCam</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>distance</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>600</span>,           
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>center</span><span style=color:#f92672>:</span> [<span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>200</span>],       
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rotation</span><span style=color:#f92672>:</span> [<span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>easycam</span>.<span style=color:#a6e22e>setState</span>(<span style=color:#a6e22e>state</span>, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 50 objects are placed throughout the space with random positions.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>30</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>randomint</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>400</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>randomint</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>400</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>z</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>randomint</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>400</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>positions</span>.<span style=color:#a6e22e>push</span>([<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>z</span>]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>texselect</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createSelect</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>texselect</span>.<span style=color:#a6e22e>position</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>texselect</span>.<span style=color:#a6e22e>option</span>(<span style=color:#e6db74>&#39;cabber&#39;</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>texselect</span>.<span style=color:#a6e22e>option</span>(<span style=color:#e6db74>&#39;mosaic&#39;</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>texselect</span>.<span style=color:#a6e22e>selected</span>(<span style=color:#e6db74>&#39;cabber&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>tex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>texselect</span>.<span style=color:#a6e22e>value</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>P</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>easycam</span>.<span style=color:#a6e22e>getPosition</span>();
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>50</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>ssize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>chromabber</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>positions</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cabberShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;SHAPE_SIZE&#39;</span>, <span style=color:#a6e22e>ssize</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cabberShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;CHROMATIC_ABBERATION&#39;</span>, <span style=color:#a6e22e>chromabber</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cabberShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;u_time&#39;</span>, <span style=color:#a6e22e>frameCount</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mosaicShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;u_time&#39;</span>, <span style=color:#a6e22e>frameCount</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>emitResolution</span>(<span style=color:#a6e22e>cabberShader</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>emitResolution</span>(<span style=color:#a6e22e>mosaicShader</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tex</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>cabberShader</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tex</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>mosaicShader</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>texture</span>(<span style=color:#a6e22e>pg</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>push</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>positions</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>positions</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>400</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>positions</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>positions</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>400</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>positions</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>positions</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>400</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>translate</span>(<span style=color:#a6e22e>positions</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>positions</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>positions</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>2</span>]); <span style=color:#75715e>// with push and pop, translation and rotation of each object is independent of each other.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>rotateX</span>(<span style=color:#a6e22e>angle</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rotateY</span>(<span style=color:#a6e22e>angle</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.4</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tex</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cone</span>(<span style=color:#a6e22e>size</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tex</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sphere</span>(<span style=color:#a6e22e>size</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pop</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ssize</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>size</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>chromabber</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.002</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tex</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>angle</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.001</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>randomint</span>(<span style=color:#a6e22e>min</span>, <span style=color:#a6e22e>max</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>min</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>ceil</span>(<span style=color:#a6e22e>min</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>max</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>max</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Math.<span style=color:#a6e22e>floor</span>(Math.<span style=color:#a6e22e>random</span>() <span style=color:#f92672>*</span> (<span style=color:#a6e22e>max</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>min</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>min</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><details><summary>Mosaic Shader Code</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#75715e>// Author @patriciogv - 2015</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Title: Mosaic</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef GL_ES</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> u_resolution;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> u_mouse;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> u_time;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> random (<span style=color:#66d9ef>vec2</span> st) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fract(sin(dot(st.xy,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>12.9898</span>,<span style=color:#ae81ff>78.233</span>)))<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>43758.5453123</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> st <span style=color:#f92672>=</span> gl_FragCoord.xy<span style=color:#f92672>/</span>u_resolution.xy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    st <span style=color:#f92672>*=</span> <span style=color:#ae81ff>10.0</span>; <span style=color:#75715e>// Scale the coordinate system by 10</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> ipos <span style=color:#f92672>=</span> floor(st);  <span style=color:#75715e>// get the integer coords</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> fpos <span style=color:#f92672>=</span> fract(st);  <span style=color:#75715e>// get the fractional coords</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Assign a random value based on the integer coord</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> color <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(random( ipos ));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Uncomment to see the subdivided grid</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// color = vec3(fpos,0.0);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(color,<span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><details><summary>Chromatic Abberration Shader Code</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Fork of &#34;generative art deco 3&#34; by morisil. https://shadertoy.com/view/mdl3WX</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2022-10-28 00:47:55</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Fork of &#34;generative art deco 2&#34; by morisil. https://shadertoy.com/view/ftVBDz</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2022-10-27 22:34:54</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Fork of &#34;generative art deco&#34; by morisil. https://shadertoy.com/view/7sKfDd</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2022-09-28 11:25:15</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Copyright Kazimierz Pogoda, 2022 - https://xemantic.com/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// I am the sole copyright owner of this Work.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// You cannot host, display, distribute or share this Work in any form,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// including physical and digital. You cannot use this Work in any</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// commercial or non-commercial product, website or project. You cannot</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// sell this Work and you cannot mint an NFTs of it.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// I share this Work for educational purposes, and you can link to it,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// through an URL, proper attribution and unmodified screenshot, as part</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// of your educational material. If these conditions are too restrictive</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// please contact me and we&#39;ll definitely work it out.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// copyright statement borrowed from Inigo Quilez</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Music by Giovanni Sollima, L&#39;invenzione del nero:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// https://soundcloud.com/giovanni-sollima/linvenzione-del-nero</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// See also The Mathematics of Perception to check the ideas behind:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// https://www.shadertoy.com/view/7sVBzK</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> SHAPE_SIZE;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> CHROMATIC_ABBERATION;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> ITERATIONS <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> INITIAL_LUMA <span style=color:#f92672>=</span> <span style=color:#ae81ff>.5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> u_resolution;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> u_time;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> PI <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14159265359</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> TWO_PI <span style=color:#f92672>=</span> <span style=color:#ae81ff>6.28318530718</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mat2</span> rotate2d(<span style=color:#66d9ef>float</span> _angle){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>mat2</span>(cos(_angle),<span style=color:#f92672>-</span>sin(_angle),
</span></span><span style=display:flex><span>                sin(_angle),cos(_angle));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> sdPolygon( <span style=color:#66d9ef>float</span> angle,  <span style=color:#66d9ef>float</span> distance) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> segment <span style=color:#f92672>=</span> TWO_PI <span style=color:#f92672>/</span> <span style=color:#ae81ff>4.0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> cos(floor(<span style=color:#ae81ff>.5</span> <span style=color:#f92672>+</span> angle <span style=color:#f92672>/</span> segment) <span style=color:#f92672>*</span> segment <span style=color:#f92672>-</span> angle) <span style=color:#f92672>*</span> distance;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> random(<span style=color:#66d9ef>vec2</span> st) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fract(sin(dot(st.xy,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>12.9898</span>,<span style=color:#ae81ff>78.233</span>)))<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>43758.5453123</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> getColorComponent( <span style=color:#66d9ef>vec2</span> st, <span style=color:#66d9ef>float</span> modScale,  <span style=color:#66d9ef>float</span> blur) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> modSt <span style=color:#f92672>=</span> mod(st, <span style=color:#ae81ff>1.</span> <span style=color:#f92672>/</span> modScale) <span style=color:#f92672>*</span> modScale <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> dist <span style=color:#f92672>=</span> length(modSt);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> angle <span style=color:#f92672>=</span> atan(modSt.x, modSt.y) <span style=color:#f92672>+</span> sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>.08</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>9.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> shapeMap <span style=color:#f92672>=</span> smoothstep(SHAPE_SIZE <span style=color:#f92672>+</span> blur, SHAPE_SIZE <span style=color:#f92672>-</span> blur, sin(dist <span style=color:#f92672>*</span> <span style=color:#ae81ff>3.0</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>.5</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>.5</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> shapeMap;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> st <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (<span style=color:#ae81ff>2.</span><span style=color:#f92672>*</span> gl_FragCoord.xy <span style=color:#f92672>-</span> u_resolution)
</span></span><span style=display:flex><span>        <span style=color:#f92672>/</span> min(u_resolution.x, u_resolution.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> origSt <span style=color:#f92672>=</span> st;
</span></span><span style=display:flex><span>    st <span style=color:#f92672>*=</span> rotate2d(sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>.14</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>.3</span>);
</span></span><span style=display:flex><span>    st <span style=color:#f92672>*=</span> (sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>.15</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>2.</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>.3</span>;
</span></span><span style=display:flex><span>    st <span style=color:#f92672>*=</span> log(length(st <span style=color:#f92672>*</span> <span style=color:#ae81ff>.428</span>)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.1</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> blur <span style=color:#f92672>=</span> <span style=color:#ae81ff>.4</span> <span style=color:#f92672>+</span> sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>.52</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>.2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> modScale <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> color <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> luma <span style=color:#f92672>=</span> INITIAL_LUMA;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>float</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.</span>; i <span style=color:#f92672>&lt;</span> ITERATIONS; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>vec2</span> center <span style=color:#f92672>=</span> st <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>.12</span>), cos(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>.13</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>//center += pow(length(center), 1.);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>vec3</span> shapeColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(
</span></span><span style=display:flex><span>            getColorComponent(center <span style=color:#f92672>-</span> st <span style=color:#f92672>*</span> CHROMATIC_ABBERATION, modScale, blur),
</span></span><span style=display:flex><span>            getColorComponent(center, modScale, blur),
</span></span><span style=display:flex><span>            getColorComponent(center <span style=color:#f92672>+</span> st <span style=color:#f92672>*</span> CHROMATIC_ABBERATION, modScale, blur)        
</span></span><span style=display:flex><span>        ) <span style=color:#f92672>*</span> luma;
</span></span><span style=display:flex><span>        st <span style=color:#f92672>*=</span> <span style=color:#ae81ff>1.1</span> <span style=color:#f92672>+</span> getColorComponent(center, modScale, <span style=color:#ae81ff>.04</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.2</span>;
</span></span><span style=display:flex><span>        st <span style=color:#f92672>*=</span> rotate2d(sin(u_time  <span style=color:#f92672>*</span> <span style=color:#ae81ff>.05</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.33</span>);
</span></span><span style=display:flex><span>        color <span style=color:#f92672>+=</span> shapeColor;
</span></span><span style=display:flex><span>        color <span style=color:#f92672>=</span> clamp(color, <span style=color:#ae81ff>0.</span>, <span style=color:#ae81ff>1.</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>//        if (color == vec3(1)) break;</span>
</span></span><span style=display:flex><span>        luma <span style=color:#f92672>*=</span> <span style=color:#ae81ff>.6</span>;
</span></span><span style=display:flex><span>        blur <span style=color:#f92672>*=</span> <span style=color:#ae81ff>.63</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> GRADING_INTENSITY <span style=color:#f92672>=</span> <span style=color:#ae81ff>.4</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> topGrading <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1.</span> <span style=color:#f92672>+</span> sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.13</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>.3</span>) <span style=color:#f92672>*</span> GRADING_INTENSITY,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1.</span> <span style=color:#f92672>+</span> sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.23</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>.3</span>) <span style=color:#f92672>*</span> GRADING_INTENSITY,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1.</span> <span style=color:#f92672>-</span> sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.33</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>.3</span>) <span style=color:#f92672>*</span> GRADING_INTENSITY
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> bottomGrading <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1.</span> <span style=color:#f92672>-</span> sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.43</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>.3</span>) <span style=color:#f92672>*</span> GRADING_INTENSITY,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1.</span> <span style=color:#f92672>-</span> sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.53</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>.3</span>) <span style=color:#f92672>*</span> GRADING_INTENSITY,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1.</span> <span style=color:#f92672>+</span> sin(u_time <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.63</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>.3</span>) <span style=color:#f92672>*</span> GRADING_INTENSITY
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> origDist <span style=color:#f92672>=</span> length(origSt);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> colorGrading <span style=color:#f92672>=</span> mix(topGrading, bottomGrading, origDist <span style=color:#f92672>-</span> <span style=color:#ae81ff>.5</span>);
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(pow(color.rgb, colorGrading), <span style=color:#ae81ff>1.</span>);
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>*=</span> smoothstep(<span style=color:#ae81ff>2.1</span>, <span style=color:#ae81ff>.7</span>, origDist);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><p><strong>4. Conclusiones</strong></p><p>En conclusión, el trabajo presentado utiliza la texturización procedural como una técnica innovadora para la generación de contenido visual en 3D. A través de algoritmos y shaders personalizados, se logra generar texturas y detalles complejos de manera eficiente y escalable.</p><p>Los antecedentes y el trabajo previo en el campo de la texturización procedural han sentado las bases para el desarrollo de esta técnica. Desde el ruido de Perlin hasta los avances en la generación de texturas basadas en fractales y principios físicos, diversos investigadores y profesionales han contribuido al avance y aplicación de la texturización procedural en diversas industrias.</p><p>La texturización procedural ofrece ventajas significativas, como la eficiencia en la generación de contenido visual, la escalabilidad en la manipulación de texturas y la capacidad de personalización y variabilidad. Estas características son especialmente valiosas en la industria del entretenimiento, donde se requiere un alto nivel de realismo y detalles en la creación de mundos virtuales en videojuegos, películas y animaciones.</p><p>El código presentado en este trabajo demuestra la implementación práctica de la texturización procedural en un entorno de programación como p5.js. Mediante shaders personalizados, se logra la generación automática y visualmente atractiva de texturas en objetos geométricos 3D.</p><p>En resumen, la texturización procedural es una técnica poderosa y versátil que ha transformado la forma en que se crea y se visualiza el contenido digital. Su aplicación en la generación de texturas y detalles realistas ha permitido avanzar en la calidad y eficiencia en la creación de mundos virtuales y ha abierto nuevas posibilidades creativas en diversas industrias.</p><p><strong>5. Trabajo a futuro</strong></p><p>En el ámbito de la texturización procedural, existen diversas áreas que ofrecen oportunidades para futuros trabajos y avances. Algunas posibles líneas de investigación y desarrollo incluyen:</p><ol><li><p>Mejora de algoritmos y técnicas: Continuar explorando y refinando los algoritmos y métodos utilizados en la texturización procedural para lograr resultados aún más realistas y detallados. Esto implica investigar nuevas técnicas de generación de texturas basadas en fractales, simulación de materiales y principios físicos, así como explorar enfoques innovadores de generación procedural.</p></li><li><p>Integración con inteligencia artificial: Explorar la integración de técnicas de inteligencia artificial, como el aprendizaje automático y las redes neuronales, en la texturización procedural. Esto podría permitir la generación automática de texturas basadas en ejemplos o la capacidad de aprender y adaptarse a estilos y preferencias específicas.</p></li><li><p>Herramientas y software mejorados: Continuar desarrollando y mejorando las herramientas y software dedicados a la texturización procedural. Esto podría implicar la creación de entornos de desarrollo más intuitivos y accesibles, la optimización de algoritmos para un rendimiento más rápido y eficiente, y la creación de bibliotecas y recursos adicionales para facilitar la implementación de la texturización procedural en diversos proyectos.</p></li><li><p>Aplicaciones en nuevas industrias: Explorar y aplicar la texturización procedural en industrias más allá del entretenimiento, como la arquitectura, el diseño de productos, la realidad virtual/aumentada, la medicina y la visualización científica. Investigar cómo la texturización procedural puede mejorar la calidad visual y la eficiencia en la creación de contenido en estas áreas.</p></li><li><p>Interacción y experiencia del usuario: Investigar y desarrollar técnicas interactivas y de tiempo real para la texturización procedural, permitiendo a los usuarios explorar y personalizar las texturas en tiempo real. Esto podría incluir interfaces de usuario intuitivas, herramientas de manipulación de parámetros en tiempo real y la capacidad de generar texturas procedurales en respuesta a la interacción del usuario.</p></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/423fbb19576d6e64d4af0c87453d7a4153eeaeec title='Last modified by Jaime | June 18, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 18, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#exercise>Exercise</a></li><li><a href=#procedural-texturing>Procedural Texturing</a><ul><li><a href=#controles>Controles</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>