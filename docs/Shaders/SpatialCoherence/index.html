<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exercise # Implement your own source dataset and a mechanism to select different images from it. Implement a pixelator in software that doesn’t use spatial coherence and compare the results with those obtained here. Introduction # La coherencia espacial se refiere a la propiedad de que los píxeles o elementos de una imagen o gráfico cercanos entre sí tienden a tener características o valores similares. Esto significa que existe una correlación o similitud en los datos espacialmente adyacentes."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Spatial Coherence"><meta property="og:description" content="Exercise # Implement your own source dataset and a mechanism to select different images from it. Implement a pixelator in software that doesn’t use spatial coherence and compare the results with those obtained here. Introduction # La coherencia espacial se refiere a la propiedad de que los píxeles o elementos de una imagen o gráfico cercanos entre sí tienden a tener características o valores similares. Esto significa que existe una correlación o similitud en los datos espacialmente adyacentes."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcomputing.github.io/showcase/docs/Shaders/SpatialCoherence/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-06-17T01:25:41-05:00"><title>Spatial Coherence | Showcase Template</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Showcase Template</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-7e4921a1bef13fc49e19193dc1bfdc8f class=toggle>
<label for=section-7e4921a1bef13fc49e19193dc1bfdc8f class="flex justify-between"><a href=/showcase/docs/members/>Members</a></label><ul><li><a href=/showcase/docs/members/Adrian/>Adrian</a></li><li><a href=/showcase/docs/members/Jaime/>Jaime</a></li><li><a href=/showcase/docs/members/Rodrigo/>Rodrigo</a></li></ul></li><li class=book-section-flat><a href=/showcase/docs/Shaders/>Shaders</a><ul><li><a href=/showcase/docs/Shaders/coloring/>Coloring</a></li><li><a href=/showcase/docs/Shaders/Texturing/>Texturing</a></li><li><a href=/showcase/docs/Shaders/non-euclidian-geometry/>Non-Euclidean geometry</a></li><li><a href=/showcase/docs/Shaders/SpatialCoherence/ class=active>Spatial Coherence</a></li><li><a href=/showcase/docs/Shaders/Photomosaic/>Photomosaic</a></li></ul></li><li class=book-section-flat><a href=/showcase/docs/Visual-Illusions/>Visual Illusions</a><ul><li><input type=checkbox id=section-99e4a0d55300f831d740177d881e77f4 class=toggle>
<label for=section-99e4a0d55300f831d740177d881e77f4 class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Coloring/>Coloring</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Coloring/Color-blindness/>Color Blindness</a></li></ul></li><li><input type=checkbox id=section-bd03a1ba8998ae8c9df2b933d511e416 class=toggle>
<label for=section-bd03a1ba8998ae8c9df2b933d511e416 class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Mach-Bands/>Mach Bands</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Mach-Bands/Terrain-with-Perlin-noise/>Terrain With Perlin Noise</a></li></ul></li><li><input type=checkbox id=section-7a7081fda5df7dbf85b6d879015de52b class=toggle>
<label for=section-7a7081fda5df7dbf85b6d879015de52b class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Masking/>Masking</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Masking/Visual-masking/>Visual Masking</a></li><li><a href=/showcase/docs/Visual-Illusions/Masking/Convolution-masks/>Convolution Masks</a></li></ul></li><li><input type=checkbox id=section-8f4e9ca131433d238729d21435de5a65 class=toggle>
<label for=section-8f4e9ca131433d238729d21435de5a65 class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Spatial-Coherence/>Spatial Coherence</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Spatial-Coherence/Pixelator-demo/>Pixelator Demo</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Spatial Coherence</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#exercise>Exercise</a></li><li><a href=#introduction>Introduction</a></li><li><a href=#background>Background</a></li><li><a href=#solution-spatial-coherence>Solution, spatial coherence</a><ul><li><a href=#controles>Controles</a></li></ul></li><li><a href=#solution-average-color>Solution, average Color</a><ul><li><a href=#controles-1>Controles</a></li></ul></li><li><a href=#conclusions>Conclusions</a></li><li><a href=#future-work>Future work</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=exercise>Exercise
<a class=anchor href=#exercise>#</a></h2><ol><li>Implement your own source dataset and a mechanism to select different images from it.</li><li>Implement a pixelator in software that doesn’t use spatial coherence and compare the results with those obtained here.</li></ol><h2 id=introduction>Introduction
<a class=anchor href=#introduction>#</a></h2><p>La coherencia espacial se refiere a la propiedad de que los píxeles o elementos de una imagen o gráfico cercanos entre sí tienden a tener características o valores similares. Esto significa que existe una correlación o similitud en los datos espacialmente adyacentes.</p><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><p>La técnica de &ldquo;spatial coherence&rdquo; o &ldquo;coherencia espacial&rdquo; tiene sus antecedentes en el campo de la informática gráfica y el procesamiento de imágenes. A continuación, se presentan algunos de los antecedentes relevantes en el uso de esta técnica:</p><p>Radiosity y Ray Tracing: A finales de la década de 1970 y principios de la década de 1980, los investigadores comenzaron a explorar métodos de renderizado más realistas, como la radiosity y el ray tracing. Estos métodos aprovechaban la coherencia espacial al propagar la luz de un punto a otro en la escena y calcular la iluminación globalmente. Al utilizar técnicas de coherencia espacial, fue posible reducir el tiempo de cálculo necesario para renderizar escenas complejas.</p><p>Algoritmos de compresión de imágenes: En el campo de la compresión de imágenes, se desarrollaron algoritmos que aprovechaban la coherencia espacial para lograr una mayor eficiencia en la representación de imágenes. Por ejemplo, los métodos de codificación predictiva utilizan la información de píxeles vecinos para predecir el valor de un píxel y, de esta manera, reducir la redundancia en los datos.</p><p>Culling y técnicas de optimización en gráficos 3D: En el ámbito de los gráficos 3D en tiempo real, se han desarrollado diversas técnicas de optimización basadas en la coherencia espacial. Por ejemplo, el ocultamiento de superficies (culling) se utiliza para evitar el procesamiento de objetos o partes de objetos que están completamente ocultos detrás de otros. Además, los algoritmos de agrupación espacial (spatial partitioning) como el octree y el árbol BSP (Binary Space Partitioning) se utilizan para dividir el espacio en regiones coherentes y acelerar la detección de colisiones y el renderizado.</p><p>Filtros de imágenes: Los filtros espaciales aplicados a imágenes, como los filtros de suavizado o enfoque, se basan en la coherencia espacial para lograr resultados visuales deseables. Estos filtros utilizan operaciones que consideran los valores de los píxeles vecinos para calcular los nuevos valores de los píxeles en la imagen filtrada.</p><h2 id=solution-spatial-coherence>Solution, spatial coherence
<a class=anchor href=#solution-spatial-coherence>#</a></h2><p>En este ejercicio, se realiza la pixelación de imágenes utilizando la técnica de coherencia espacial. El proceso se lleva a cabo mediante un shader llamado &ldquo;pixelator&rdquo;, el cual recibe la imagen original y la resolución deseada. Al especificar una resolución de 30, por ejemplo, la imagen pixelada tendrá píxeles de baja resolución (grandes) en cada lado, totalizando 30 píxeles.</p><p>El mecanismo de coherencia espacial funciona de la siguiente manera: para cada texel (píxel de la textura), se recibe una coordenada normalizada en el rango de [0..1]. Cada componente de la coordenada se multiplica por la resolución, lo que ajusta su valor al rango [0..30]. A continuación, se aplica la función piso a estos componentes, lo que resulta en un redondeo hacia abajo. Por ejemplo, todas las coordenadas dentro del espacio [2, 3) x [2, 3) se mapearán a la coordenada (2, 2). Luego, esta coordenada se divide entre la resolución para obtener nuevamente valores normalizados. El color correspondiente a la coordenada (2, 2) se asigna a todos los texeles que se encuentren en el rango [2, 3) x [2, 3). La coherencia espacial se aplica asumiendo que este color será cercano a los colores de todos los texeles mapeados a esa coordenada, aunque esto no sea cierto en todos los casos, pero es altamente probable.</p><p>Además, se ha agregado una implementación alternativa que no utiliza la coherencia espacial, lo cual permite al usuario comparar los resultados. Esta implementación pinta cada píxel de baja resolución con el color promedio de los píxeles mapeados a esa coordenada. Esta aplicación se realiza mediante software, sin utilizar shaders. El usuario debe cargar manualmente la imagen que desea comparar en ambas implementaciones y ajustar el control deslizante para que ambas tengan la misma resolución.</p><p>Al observar los resultados, se nota que no hay una gran diferencia en los colores utilizados en los píxeles de baja resolución. Incluso puede parecer que la coherencia espacial muestra la imagen pixelada con un poco más de detalle, mientras que la implementación que utiliza el promedio de los colores parece tener un efecto de desenfoque o algo similar.</p><p>Es importante mencionar que la implementación sin coherencia espacial no admite videos y solo se puede realizar la comparación con imágenes estáticas.</p><h3 id=controles>Controles
<a class=anchor href=#controles>#</a></h3><ul><li><strong>Botón Seleccionar archivo</strong>: para cargar una imagen o video</li><li><strong>Checkbox Video por defecto</strong>: marcar para usar el video por defecto, desmarcar para usar la imagen por defecto</li><li><strong>Slider</strong>: define la resolución (por defecto 30, es decir 30 pixeles de baja resolución por cada lado de la cuadrícula). El mínimo valor es 1 y el máximo 150. Una resolución mayor, implica más pixeles, y por tanto, de menor tamaño cada vez. El tamaño de la cuadrícula es de 600px x 600px por lo que una resolución de 150 implica pixeles de baja resolución de dimensiones 4px x 4px.</li><li><strong>Select</strong>: para decidir si ver la imagen pixelada o la original</li></ul><iframe id=scoherence style=width:650px;height:750px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js></script>
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
            
            
            
            
            <script src=/showcase/sketches/shaders/SpatialCoherence/scoherence.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe>
<details><summary>Sketch Code</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#e6db74>&#39;use strict&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>img</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>pixelatorShader</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>resolution</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>mode</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>input</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>imgcode</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dataset</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>video_on</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>preload</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>`/showcase/docs/Shaders/resources/scoherence.jpg`</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pixelatorShader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>readShader</span>(<span style=color:#e6db74>&#39;/showcase/docs/Shaders/fragments/pixelator.frag&#39;</span>, { <span style=color:#a6e22e>matrices</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Tree</span>.<span style=color:#a6e22e>NONE</span>, <span style=color:#a6e22e>varyings</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Tree</span>.<span style=color:#a6e22e>texcoords2</span> });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>600</span>, <span style=color:#ae81ff>600</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>textureMode</span>(<span style=color:#a6e22e>NORMAL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noStroke</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>pixelatorShader</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>resolution</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createSlider</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>150</span>, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>position</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;width&#39;</span>, <span style=color:#e6db74>&#39;150px&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>input</span>(() =&gt; <span style=color:#a6e22e>pixelatorShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;resolution&#39;</span>, <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>value</span>()));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pixelatorShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;resolution&#39;</span>, <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createSelect</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span>.<span style=color:#a6e22e>position</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span>.<span style=color:#a6e22e>option</span>(<span style=color:#e6db74>&#39;original&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span>.<span style=color:#a6e22e>option</span>(<span style=color:#e6db74>&#39;pixelator&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span>.<span style=color:#a6e22e>selected</span>(<span style=color:#e6db74>&#39;pixelator&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span>.<span style=color:#a6e22e>changed</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>mode</span>.<span style=color:#a6e22e>value</span>() <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;original&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>hide</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>show</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pixelatorShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;original&#39;</span>, <span style=color:#a6e22e>mode</span>.<span style=color:#a6e22e>value</span>() <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;original&#39;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>input</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createFileInput</span>(<span style=color:#a6e22e>handleFile</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>imgcode</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createInput</span>(<span style=color:#e6db74>&#39;&#39;</span>, <span style=color:#e6db74>&#39;number&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>imgcode</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;display&#39;</span>, <span style=color:#e6db74>&#39;none&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>video_on</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createCheckbox</span>(<span style=color:#e6db74>&#39;Video por defecto&#39;</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>video_on</span>.<span style=color:#a6e22e>changed</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>video_on</span>.<span style=color:#a6e22e>checked</span>()) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createVideo</span>([<span style=color:#e6db74>&#39;/showcase/docs/Shaders/resources/scoherence.mp4&#39;</span>]);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>hide</span>();
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>loop</span>();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>`/showcase/docs/Shaders/resources/scoherence.jpg`</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>hide</span>();
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>pause</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pixelatorShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;source&#39;</span>, <span style=color:#a6e22e>img</span>);
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>imgcode</span>.<span style=color:#a6e22e>value</span>() <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>dataset</span>[(parseInt(<span style=color:#a6e22e>imgcode</span>.<span style=color:#a6e22e>value</span>()) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> <span style=color:#a6e22e>dataset</span>.<span style=color:#a6e22e>length</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>img</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>image</span>(<span style=color:#a6e22e>img</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>600</span>, <span style=color:#ae81ff>600</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pixelatorShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;source&#39;</span>, <span style=color:#a6e22e>img</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>beginShape</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>vertex</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>vertex</span>(<span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>vertex</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>vertex</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>endShape</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleFile</span>(<span style=color:#a6e22e>file</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;image&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createImg</span>(<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>data</span>, <span style=color:#e6db74>&#39;&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>hide</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;video&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createVideo</span>([<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>data</span>]);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>hide</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>loop</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>imgcode</span>.<span style=color:#a6e22e>value</span>(<span style=color:#e6db74>&#39;&#39;</span>) <span style=color:#75715e>// to avoid getting dataset image instead
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><details><summary>Pixelator Shader Code</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// source (image or video) is sent by the sketch</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>sampler2D</span> source;
</span></span><span style=display:flex><span><span style=color:#75715e>// displays original</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>bool</span> original;
</span></span><span style=display:flex><span><span style=color:#75715e>// target horizontal &amp; vertical resolution</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> resolution;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// interpolated texcoord (same name and type as in vertex shader)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// defined as a (normalized) vec2 in [0..1]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>varying</span> <span style=color:#66d9ef>vec2</span> texcoords2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (original) {
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>=</span> texture2D(source, texcoords2);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// define stepCoord to sample the texture source as a 3-step process:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// i. define stepCoord as a texcoords2 remapping in [0.0, resolution] ∈ R</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> stepCoord <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>*</span> resolution;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ii. remap stepCoord in [0.0, resolution] ∈ Z</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// see: https://thebookofshaders.com/glossary/?search=floor</span>
</span></span><span style=display:flex><span>    stepCoord <span style=color:#f92672>=</span> floor(stepCoord);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// iii. remap stepCoord in [0.0, 1.0] ∈ R</span>
</span></span><span style=display:flex><span>    stepCoord <span style=color:#f92672>=</span> stepCoord <span style=color:#f92672>/</span> <span style=color:#66d9ef>vec2</span>(resolution);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// source texel</span>
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>=</span> texture2D(source, stepCoord);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ✨ source texels may be used to compute image palette lookup keys,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// such as in video &amp; photographic mosaics or ascii art visualizations.</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h2 id=solution-average-color>Solution, average Color
<a class=anchor href=#solution-average-color>#</a></h2><p>A continuación se presenta la implementación realizada en software (no en hardware) para la pixelación sin utilizar coherencia espacial. En este enfoque, en lugar de seleccionar un pixel arbitrario de una sección para pintar el píxel de baja resolución correspondiente, se realiza un promedio de los colores de todos los píxeles en dicha sección y se utiliza ese valor para pintar el píxel de baja resolución.</p><p>Para utilizar esta implementación, el usuario debe cargar manualmente la imagen (puede descargar la versión original haciendo clic derecho sobre la imagen en la aplicación que utiliza coherencia espacial y luego cargarla aquí). Además, es necesario ajustar el control deslizante (slider) si es necesario, para que ambas implementaciones tengan la misma resolución y así poder realizar la comparación entre ellas.</p><h3 id=controles-1>Controles
<a class=anchor href=#controles-1>#</a></h3><ul><li><strong>Botón Seleccionar archivo</strong>: para cargar una imagen o video</li><li><strong>Slider</strong>: define la resolución (por defecto 30, es decir 30 pixeles de baja resolución por cada lado de la cuadrícula). El mínimo valor es 1 y el máximo 150. Una resolución mayor, implica más pixeles, y por tanto, de menor tamaño cada vez. El tamaño de la cuadrícula es de 600px x 600px por lo que una resolución de 150 implica pixeles de baja resolución de dimensiones 4px x 4px.</li></ul><iframe id=average style=width:650px;height:750px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/shaders/SpatialCoherence/average.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe>
<details><summary>Sketch Code</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>mid</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; <span style=color:#75715e>// pixel width and height: split is in groups of 256 pixels.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>input</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>img</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>width</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>height</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>resolution</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>input</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createFileInput</span>(<span style=color:#a6e22e>handleFile</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resolution</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createSlider</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>150</span>, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>position</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;width&#39;</span>, <span style=color:#e6db74>&#39;150px&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>input</span>(() =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>floor</span>(<span style=color:#ae81ff>600</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mid</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>w</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>img</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>width</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>600</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>height</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>600</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>position</span>(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>width</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>image</span>(<span style=color:#a6e22e>img</span>, <span style=color:#a6e22e>width</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>600</span>, <span style=color:#ae81ff>600</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fill</span>(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>noStroke</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>width</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>w</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>height</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>w</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>square</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>w</span>);
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>        }   
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>COLORS</span> <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>width</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i_</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>width</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>height</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>i_</span>, <span style=color:#a6e22e>j</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span>Math.<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>w</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>-</span><span style=color:#e6db74>${</span>Math.<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>j</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>w</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>COLORS</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>COLORS</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>COLORS</span>[<span style=color:#a6e22e>key</span>].<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>color</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>COLORS</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>colors</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>COLORS</span>[<span style=color:#a6e22e>key</span>]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>R</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>G</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>B</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>colors</span>.<span style=color:#a6e22e>forEach</span>((<span style=color:#a6e22e>c</span>) =&gt; {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>R</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>c</span>[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>G</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>c</span>[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>B</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>c</span>[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>COLORS</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>=</span> [Math.<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>R</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>w</span><span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>), Math.<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>G</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>w</span><span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>), Math.<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>B</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>w</span><span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>)]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>COLORS</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>fill</span>(<span style=color:#a6e22e>COLORS</span>[<span style=color:#a6e22e>key</span>])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> parseInt(<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39;-&#39;</span>)[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> parseInt(<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39;-&#39;</span>)[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>square</span>(<span style=color:#a6e22e>x</span><span style=color:#f92672>*</span><span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>y</span><span style=color:#f92672>*</span><span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>w</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleFile</span>(<span style=color:#a6e22e>file</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;image&#39;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createImg</span>(<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>data</span>, <span style=color:#e6db74>&#39;&#39;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>hide</span>();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div></div></details><h2 id=conclusions>Conclusions
<a class=anchor href=#conclusions>#</a></h2><p>El uso de la técnica de coherencia espacial en el procesamiento de imágenes y gráficos tiene varias conclusiones destacadas:</p><p>Optimización de algoritmos: La coherencia espacial permite optimizar algoritmos al aprovechar la correlación y similitud entre datos espacialmente adyacentes. Esto reduce la carga computacional al evitar cálculos redundantes y mejorar la eficiencia en el procesamiento de grandes conjuntos de datos.</p><p>Mejora del rendimiento: Al reducir el número de operaciones repetitivas y optimizar el procesamiento de datos coherentes, se logra un mejor rendimiento en aplicaciones gráficas y de procesamiento de imágenes en tiempo real. Esto es especialmente valioso en situaciones donde se requiere una respuesta rápida, como en juegos, simulaciones interactivas o visualización de datos en tiempo real.</p><p>Mayor realismo y calidad visual: La coherencia espacial puede utilizarse para mejorar la calidad visual de las imágenes y gráficos generados. Al considerar la relación entre píxeles o elementos cercanos, se pueden aplicar técnicas de suavizado, iluminación global y sombreado más precisos, lo que conduce a resultados más realistas y atractivos visualmente.</p><p>Reducción de artefactos y ruido: Al aplicar la coherencia espacial en la manipulación de imágenes, se pueden reducir los artefactos y el ruido en las imágenes resultantes. Al tomar en cuenta la relación espacial entre los píxeles, se puede minimizar la distorsión y los efectos no deseados que pueden surgir al realizar operaciones de filtrado, compresión o transformación.</p><p>Flexibilidad y adaptabilidad: La técnica de coherencia espacial es aplicable en una variedad de contextos y algoritmos. Puede utilizarse en diferentes etapas del procesamiento de imágenes y gráficos, y se puede adaptar según las necesidades específicas de cada aplicación. Esto la convierte en una herramienta versátil para optimizar y mejorar diversos aspectos del procesamiento visual.</p><h2 id=future-work>Future work
<a class=anchor href=#future-work>#</a></h2><p>La técnica de coherencia espacial tiene un amplio potencial en diversas áreas y se pueden vislumbrar varias aplicaciones futuras. Algunas de ellas son:</p><p>Renderizado en tiempo real: La coherencia espacial puede ser utilizada para mejorar la eficiencia y calidad del renderizado en tiempo real en videojuegos y simulaciones interactivas. Al optimizar los cálculos de iluminación, sombreado y efectos visuales basándose en la coherencia espacial, se puede lograr un mayor nivel de detalle y realismo visual sin comprometer el rendimiento.</p><p>Realidad virtual y aumentada: En el contexto de la realidad virtual y aumentada, la coherencia espacial puede ser empleada para mejorar la interacción y la integración de los objetos virtuales en el entorno real. Al considerar la relación espacial entre los objetos virtuales y el entorno físico, se pueden lograr transiciones suaves, detección precisa de colisiones y efectos visuales más realistas.</p><p>Compresión de imágenes y video: La coherencia espacial puede utilizarse para desarrollar algoritmos de compresión más eficientes y efectivos. Al aprovechar las correlaciones espaciales entre los píxeles de una imagen o fotogramas consecutivos en un video, se pueden lograr tasas de compresión más altas sin pérdida significativa de calidad visual.</p><p>Procesamiento de imágenes médicas: En el campo de la medicina, la coherencia espacial puede ser aplicada al procesamiento de imágenes médicas para mejorar la detección de anomalías y facilitar el análisis clínico. Al considerar la relación espacial entre los tejidos o estructuras en una imagen médica, se pueden desarrollar algoritmos de segmentación y análisis más precisos.</p><p>Reconocimiento de objetos y visión por computadora: En aplicaciones de visión por computadora y reconocimiento de objetos, la coherencia espacial puede ayudar a mejorar la precisión y robustez de los algoritmos. Al considerar la relación espacial entre los diferentes elementos de una escena o imagen, se pueden desarrollar modelos de reconocimiento más sólidos y capaces de manejar diversas variaciones y transformaciones.</p><p>Generación de contenido procedural: La coherencia espacial puede ser utilizada en la generación procedural de contenido, como la creación de terrenos, paisajes, texturas y objetos virtuales. Al considerar las correlaciones espaciales en la generación de detalles y características, se pueden lograr resultados más coherentes y naturales.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/e12ccd7b2178d64b651afb2cea81ed78811fb045 title='Last modified by Donret | June 17, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 17, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#exercise>Exercise</a></li><li><a href=#introduction>Introduction</a></li><li><a href=#background>Background</a></li><li><a href=#solution-spatial-coherence>Solution, spatial coherence</a><ul><li><a href=#controles>Controles</a></li></ul></li><li><a href=#solution-average-color>Solution, average Color</a><ul><li><a href=#controles-1>Controles</a></li></ul></li><li><a href=#conclusions>Conclusions</a></li><li><a href=#future-work>Future work</a></li></ul></li></ul></nav></div></aside></main></body></html>