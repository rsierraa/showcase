<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exercise # Implement some posteffects you find interesting. 1. Introducción y contexto
Un shader es básicamente un programa que realiza cálculos matemáticos, con el propósito de materializar efectos gráficos deseados. Siendo los cálculos realizados por una computadora (generalmente una GPU), y los efectos añadidos, por lo general, a un programa más grande que demuestra gráficos.
https://en.wikipedia.org/wiki/Shader God Rays Shader # Un shader de God Rays es, como su nombre lo dice, un efecto que añade rayos de luz luminosos sobre una imágen."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Post Effects"><meta property="og:description" content="Exercise # Implement some posteffects you find interesting. 1. Introducción y contexto
Un shader es básicamente un programa que realiza cálculos matemáticos, con el propósito de materializar efectos gráficos deseados. Siendo los cálculos realizados por una computadora (generalmente una GPU), y los efectos añadidos, por lo general, a un programa más grande que demuestra gráficos.
https://en.wikipedia.org/wiki/Shader God Rays Shader # Un shader de God Rays es, como su nombre lo dice, un efecto que añade rayos de luz luminosos sobre una imágen."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcomputing.github.io/showcase/docs/Shaders/posteffects/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-06-19T21:56:31-05:00"><title>Post Effects | Visual Computing 2023-1</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Visual Computing 2023-1</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-7e4921a1bef13fc49e19193dc1bfdc8f class=toggle>
<label for=section-7e4921a1bef13fc49e19193dc1bfdc8f class="flex justify-between"><a href=/showcase/docs/members/>Members</a></label><ul><li><a href=/showcase/docs/members/Adrian/>Adrian</a></li><li><a href=/showcase/docs/members/Jaime/>Jaime</a></li><li><a href=/showcase/docs/members/Rodrigo/>Rodrigo</a></li></ul></li><li class=book-section-flat><a href=/showcase/docs/Shaders/>Shaders</a><ul><li><a href=/showcase/docs/Shaders/coloring/>Coloring</a></li><li><a href=/showcase/docs/Shaders/posteffects/ class=active>Post Effects</a></li><li><a href=/showcase/docs/Shaders/test/>Test</a></li><li><a href=/showcase/docs/Shaders/Texturing/>Texturing</a></li><li><a href=/showcase/docs/Shaders/ImageProcessing/>Image Processing</a></li><li><a href=/showcase/docs/Shaders/ProceduralTexturing/>Procedural Texturing</a></li><li><a href=/showcase/docs/Shaders/SpatialCoherence/>Spatial Coherence</a></li><li><a href=/showcase/docs/Shaders/Photomosaic/>Photomosaic</a></li></ul></li><li class=book-section-flat><a href=/showcase/docs/Transformations/>Transformations</a><ul><li><a href=/showcase/docs/Transformations/hola1/>Hola1</a></li></ul></li><li class=book-section-flat><a href=/showcase/docs/Visual-Illusions/>Visual Illusions</a><ul><li><input type=checkbox id=section-99e4a0d55300f831d740177d881e77f4 class=toggle>
<label for=section-99e4a0d55300f831d740177d881e77f4 class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Coloring/>Coloring</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Coloring/Color-blindness/>Color Blindness</a></li></ul></li><li><input type=checkbox id=section-bd03a1ba8998ae8c9df2b933d511e416 class=toggle>
<label for=section-bd03a1ba8998ae8c9df2b933d511e416 class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Mach-Bands/>Mach Bands</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Mach-Bands/Terrain-with-Perlin-noise/>Terrain With Perlin Noise</a></li></ul></li><li><input type=checkbox id=section-7a7081fda5df7dbf85b6d879015de52b class=toggle>
<label for=section-7a7081fda5df7dbf85b6d879015de52b class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Masking/>Masking</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Masking/Visual-masking/>Visual Masking</a></li><li><a href=/showcase/docs/Visual-Illusions/Masking/Convolution-masks/>Convolution Masks</a></li></ul></li><li><input type=checkbox id=section-8f4e9ca131433d238729d21435de5a65 class=toggle>
<label for=section-8f4e9ca131433d238729d21435de5a65 class="flex justify-between"><a href=/showcase/docs/Visual-Illusions/Spatial-Coherence/>Spatial Coherence</a></label><ul><li><a href=/showcase/docs/Visual-Illusions/Spatial-Coherence/Pixelator-demo/>Pixelator Demo</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Post Effects</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#exercise>Exercise</a></li><li><a href=#god-rays-shader>God Rays Shader</a></li><li><a href=#noise-warp-shader>Noise Warp Shader</a><ul><li><a href=#controles>Controles</a></li></ul></li><li><a href=#difucultades>Difucultades</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=exercise>Exercise
<a class=anchor href=#exercise>#</a></h2><ol><li>Implement some posteffects you find interesting.</li></ol><p><strong>1. Introducción y contexto</strong></p><p>Un shader es básicamente un programa que realiza cálculos matemáticos, con el propósito de materializar efectos gráficos deseados. Siendo los cálculos realizados por una computadora (generalmente una GPU), y los efectos añadidos, por lo general, a un programa más grande que demuestra gráficos.</p><blockquote class="book-hint info"><a href=https://en.wikipedia.org/wiki/Shader>https://en.wikipedia.org/wiki/Shader</a></blockquote><h2 id=god-rays-shader>God Rays Shader
<a class=anchor href=#god-rays-shader>#</a></h2><p>Un shader de God Rays es, como su nombre lo dice, un efecto que añade rayos de luz luminosos sobre una imágen. Por lo general el efecto incluye algún modo de fusionar el efecto de luz con el fondo, para lograr que se vea como luz sobre la imágen y no simplemente como una superposición.</p><blockquote class="book-hint info"><a href=https://godotshaders.com/shader/god-rays/>https://godotshaders.com/shader/god-rays/</a></blockquote><p>Aquí podemos observar un ejemplo de un shader de God Rays implementado por el portal godotshaders.com:</p><details><summary>Sketch Code</summary><div class=markdown-inner><p>/*
Shader from Godot Shaders - the free shader library.
godotshaders.com/shader/god-rays</p><p>Feel free to use, improve and change this shader according to your needs
and consider sharing the modified result on godotshaders.com.
*/</p><p>shader_type canvas_item;</p><p>uniform float angle = -0.3;
uniform float position = -0.2;
uniform float spread : hint_range(0.0, 1.0) = 0.5;
uniform float cutoff : hint_range(-1.0, 1.0) = 0.1;
uniform float falloff : hint_range(0.0, 1.0) = 0.2;
uniform float edge_fade : hint_range(0.0, 1.0) = 0.15;</p><p>uniform float speed = 1.0;
uniform float ray1_density = 8.0;
uniform float ray2_density = 30.0;
uniform float ray2_intensity : hint_range(0.0, 1.0) = 0.3;</p><p>uniform vec4 color : hint_color = vec4(1.0, 0.9, 0.65, 0.8);</p><p>uniform bool hdr = false;
uniform float seed = 5.0;</p><p>// Random and noise functions from Book of Shader&rsquo;s chapter on Noise.
float random(vec2 _uv) {
return fract(sin(dot(_uv.xy,
vec2(12.9898, 78.233))) *
43758.5453123);
}</p><p>float noise (in vec2 uv) {
vec2 i = floor(uv);
vec2 f = fract(uv);</p><pre><code>// Four corners in 2D of a tile
float a = random(i);
float b = random(i + vec2(1.0, 0.0));
float c = random(i + vec2(0.0, 1.0));
float d = random(i + vec2(1.0, 1.0));


// Smooth Interpolation

// Cubic Hermine Curve. Same as SmoothStep()
vec2 u = f * f * (3.0-2.0 * f);

// Mix 4 coorners percentages
return mix(a, b, u.x) +
        (c - a)* u.y * (1.0 - u.x) +
        (d - b) * u.x * u.y;
</code></pre><p>}</p><p>mat2 rotate(float _angle){
return mat2(vec2(cos(_angle), -sin(_angle)),
vec2(sin(_angle), cos(_angle)));
}</p><p>vec4 screen(vec4 base, vec4 blend){
return 1.0 - (1.0 - base) * (1.0 - blend);
}</p><p>void fragment()
{</p><pre><code>// Rotate, skew and move the UVs
vec2 transformed_uv = ( rotate(angle) * (UV - position) )  / ( (UV.y + spread) - (UV.y * spread) );

// Animate the ray according the the new transformed UVs
vec2 ray1 = vec2(transformed_uv.x * ray1_density + sin(TIME * 0.1 * speed) * (ray1_density * 0.2) + seed, 1.0);
vec2 ray2 = vec2(transformed_uv.x * ray2_density + sin(TIME * 0.2 * speed) * (ray1_density * 0.2) + seed, 1.0);

// Cut off the ray's edges
float cut = step(cutoff, transformed_uv.x) * step(cutoff, 1.0 - transformed_uv.x);
ray1 *= cut;
ray2 *= cut;

// Apply the noise pattern (i.e. create the rays)
float rays;

if (hdr){
	// This is not really HDR, but check this to not clamp the two merged rays making 
	// their values go over 1.0. Can make for some nice effect
	rays = noise(ray1) + (noise(ray2) * ray2_intensity);
}
else{
	 rays = clamp(noise(ray1) + (noise(ray2) * ray2_intensity), 0., 1.);
}

// Fade out edges
rays *= smoothstep(0.0, falloff, (1.0 - UV.y)); // Bottom
rays *= smoothstep(0.0 + cutoff, edge_fade + cutoff, transformed_uv.x); // Left
rays *= smoothstep(0.0 + cutoff, edge_fade + cutoff, 1.0 - transformed_uv.x); // Right

// Color to the rays
vec3 shine = vec3(rays) * color.rgb;

// Try different blending modes for a nicer effect. &quot;Screen&quot; is included in the code,
// but take a look at https://godotshaders.com/snippet/blending-modes/ for more.
// With &quot;Screen&quot; blend mode:
shine = screen(texture(SCREEN_TEXTURE, SCREEN_UV), vec4(color)).rgb;

COLOR = vec4(shine, rays * color.a);
</code></pre><p>}</p></div></details><p>El shader utiliza varios parámetros para controlar la apariencia de los rayos de luz divinos. Estos parámetros se definen al comienzo del shader y pueden ajustarse según las necesidades del usuario.</p><p>El parámetro &ldquo;angle&rdquo; controla el ángulo de los rayos de luz. Un valor negativo hará que los rayos se inclinen hacia la izquierda, mientras que un valor positivo los inclinará hacia la derecha.</p><p>El parámetro &ldquo;position&rdquo; ajusta la posición de los rayos de luz. Un valor negativo moverá los rayos hacia arriba, mientras que un valor positivo los moverá hacia abajo.</p><p>El parámetro &ldquo;spread&rdquo; determina cuánto se separan los rayos de luz a medida que se alejan de la fuente luminosa. Un valor más alto resultará en rayos más separados, mientras que un valor más bajo los hará más cercanos entre sí.</p><p>El parámetro &ldquo;cutoff&rdquo; controla la intensidad de los rayos de luz en los bordes. Un valor más alto hará que los bordes de los rayos sean más nítidos y oscuros, mientras que un valor más bajo los hará más suaves y transparentes.</p><p>El parámetro &ldquo;falloff&rdquo; determina cómo disminuye la intensidad de los rayos a medida que se alejan de la fuente luminosa. Un valor más alto resultará en una atenuación más rápida, mientras que un valor más bajo hará que los rayos se atenúen más gradualmente.</p><p>El parámetro &ldquo;edge_fade&rdquo; controla la suavidad de la transición entre los rayos y el fondo. Un valor más alto hará que la transición sea más suave y gradual, mientras que un valor más bajo la hará más brusca.</p><p>El parámetro &ldquo;speed&rdquo; ajusta la velocidad de animación de los rayos de luz. Un valor más alto hará que los rayos se muevan más rápidamente, mientras que un valor más bajo los hará más lentos.</p><p>Los parámetros &ldquo;ray1_density&rdquo; y &ldquo;ray2_density&rdquo; controlan la densidad de los rayos de luz. Valores más altos resultarán en rayos más densos, mientras que valores más bajos harán que sean más dispersos.</p><p>El parámetro &ldquo;ray2_intensity&rdquo; determina la intensidad de los rayos de luz secundarios. Un valor más alto hará que estos rayos sean más visibles, mientras que un valor más bajo los hará menos notorios.</p><p>El parámetro &ldquo;color&rdquo; establece el color de los rayos de luz. Se utiliza un valor de tipo &ldquo;vec4&rdquo; que representa el color en formato RGBA (rojo, verde, azul, alfa). El color predeterminado es un tono amarillo claro.</p><p>El parámetro &ldquo;hdr&rdquo; es un booleano que indica si se utiliza un rango dinámico alto (HDR) para los rayos de luz. Si se establece en verdadero, los valores de los rayos no se limitarán a 1.0, lo que puede generar efectos visuales interesantes.</p><p>El parámetro &ldquo;seed&rdquo; es un valor numérico utilizado como semilla para generar los patrones de ruido en los rayos de luz.</p><p>El shader utiliza una función llamada &ldquo;random&rdquo; para generar números pseudoaleatorios basados en una función hash. Esta función se utiliza para crear patrones de ruido en los rayos de luz.</p><p>Además, el shader utiliza una función llamada &ldquo;rotate&rdquo; para aplicar una rotación a las coordenadas de textura. Esta función utiliza el ángulo especificado por el parámetro &ldquo;angle&rdquo; para rotar las coordenadas.</p><p>La función &ldquo;screen&rdquo; se utiliza para combinar los rayos de luz con el color de fondo. Esta función aplica un efecto de mezcla que resulta en un resplandor de luz más suave y natural.</p><p>En la función &ldquo;fragment&rdquo;, se lleva a cabo todo el procesamiento del shader. Primero, se aplican transformaciones a las coordenadas de textura para ajustar el ángulo y la posición de los rayos de luz.</p><p>A continuación, se animan los rayos de luz utilizando las coordenadas de textura transformadas y los parámetros de densidad y velocidad. También se aplica un corte a los bordes de los rayos de luz para controlar su extensión.</p><p>Después, se aplica un patrón de ruido a los rayos de luz utilizando la función &ldquo;noise&rdquo;. Dependiendo del valor del parámetro &ldquo;hdr&rdquo;, se puede permitir que los valores de los rayos excedan 1.0, lo que genera efectos visuales interesantes.</p><p>Finalmente, se realiza un suavizado en los bordes de los rayos de luz y se mezclan con el color de los rayos utilizando la función &ldquo;smoothstep&rdquo;. También se aplica un efecto de mezcla de pantalla utilizando la función &ldquo;screen&rdquo; para obtener un aspecto más agradable.</p><p>El resultado final se asigna a la variable &ldquo;COLOR&rdquo;, que representa el color de salida del shader.</p><p>Este es el funcionamiento básico del shader de rayos de luz divinos en Godot. Sin embargo, se pueden realizar ajustes y modificaciones adicionales según las necesidades y preferencias del usuario.</p><h2 id=noise-warp-shader>Noise Warp Shader
<a class=anchor href=#noise-warp-shader>#</a></h2><p>Un &ldquo;noise warp shader&rdquo; es un tipo de shader utilizado en computación gráfica para aplicar deformaciones y distorsiones a una textura o a un objeto en una escena. El término &ldquo;noise warp&rdquo; hace referencia a la utilización de funciones de ruido para generar variaciones y perturbaciones en las coordenadas de textura o en las posiciones de los vértices de un objeto.</p><p>El ruido, en este contexto, se refiere a una función matemática que genera valores pseudoaleatorios en una distribución aparentemente aleatoria pero coherente. Estas funciones de ruido son utilizadas en computación gráfica para crear efectos orgánicos, naturales y realistas.</p><p>En un &ldquo;noise warp shader&rdquo;, el ruido se aplica para distorsionar las coordenadas de textura o las posiciones de los vértices de un objeto. Esto puede lograrse de diferentes maneras, como desplazando las coordenadas o las posiciones según los valores generados por la función de ruido.</p><p>Al aplicar estas deformaciones basadas en ruido, se pueden lograr efectos visuales interesantes y naturales, como ondulaciones, fracturas, superficies rugosas o incluso efectos de fuego y humo. Estos efectos son especialmente útiles en la creación de terrenos, texturas orgánicas, animaciones fluidas y otros elementos visuales complejos.</p><p>El &ldquo;noise warp shader&rdquo; puede ser utilizado en diferentes etapas del pipeline gráfico, como la generación de geometría, el procesamiento de vértices o el sombreado de fragmentos. Esto depende de la forma en que se desee aplicar la deformación y del nivel de detalle y control requerido en la aplicación específica.</p><p>En resumen, un &ldquo;noise warp shader&rdquo; es un shader que utiliza funciones de ruido para aplicar deformaciones y distorsiones basadas en ruido a una textura o a un objeto en una escena. Estas deformaciones generan efectos visuales realistas y orgánicos, y son ampliamente utilizadas en la computación gráfica para crear una amplia gama de efectos y elementos visuales complejos.</p><blockquote class="book-hint info">Un ejemplo de Warp Shader con ruido en GLSL:
<a href=https://www.shadertoy.com/view/ttsfzH>https://www.shadertoy.com/view/ttsfzH</a></blockquote><h3 id=controles>Controles
<a class=anchor href=#controles>#</a></h3><ul><li><strong>Botón Choose File</strong>: para cargar una imagen o video</li><li><strong>Checkbox Default Video</strong>: marcar para usar el video por defecto, desmarcar para usar la imagen por defecto</li><li><strong>Select</strong>: selecciona entre original, luma, value, lightness, intensity o tinting</li><li><strong>Select (Blending Mode)</strong>: selecciona el blending mode que desea utilizar (visible cuando se selecciona tinting)</li><li><strong>Slider</strong>: controla el brillo (visible cuando se selecciona tinting)</li><li><strong>Color Pickers</strong>: para seleccionar los colores que se aplicarán en el tinting</li></ul><iframe id=postman style=width:800px;height:650px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js></script>
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
            
            
            
            
            <script src=/showcase/sketches/shaders/postmalone/postman.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe>
<details><summary>Sketch Code</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>image_pg</span>, <span style=color:#a6e22e>noiseWarp_pg</span>, <span style=color:#a6e22e>godrays_pg</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>imageTexture</span>, <span style=color:#a6e22e>noiseWarpShader</span>, <span style=color:#a6e22e>godraysShader</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>noiseScale</span>, <span style=color:#a6e22e>noiseStrength</span>, <span style=color:#a6e22e>godraysIntensity</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>preload</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>imageTexture</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;/showcase/content/sketches/shaders/postmalone/post.jpg&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseWarpShader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadShader</span>(<span style=color:#e6db74>&#39;/showcase/content/docs/Shaders/fragments/noiseWarpShader.frag&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godraysShader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadShader</span>(<span style=color:#e6db74>&#39;/showcase/content/docs/Shaders/fragments/godraysShader.frag&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>600</span>, <span style=color:#ae81ff>600</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>image_pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createGraphics</span>(<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseWarp_pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createGraphics</span>(<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godrays_pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createGraphics</span>(<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseScale</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createSlider</span>(<span style=color:#ae81ff>0.001</span>, <span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.01</span>, <span style=color:#ae81ff>0.001</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseScale</span>.<span style=color:#a6e22e>position</span>(<span style=color:#a6e22e>width</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>120</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseScale</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;width&#39;</span>, <span style=color:#e6db74>&#39;80px&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseScale</span>.<span style=color:#a6e22e>input</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>noiseWarpShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;noiseScale&#39;</span>, <span style=color:#a6e22e>noiseScale</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseWarpShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;noiseScale&#39;</span>, <span style=color:#a6e22e>noiseScale</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseStrength</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createSlider</span>(<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0.1</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseStrength</span>.<span style=color:#a6e22e>position</span>(<span style=color:#a6e22e>width</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>120</span>, <span style=color:#ae81ff>35</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseStrength</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;width&#39;</span>, <span style=color:#e6db74>&#39;80px&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseStrength</span>.<span style=color:#a6e22e>input</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>noiseWarpShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;noiseStrength&#39;</span>, <span style=color:#a6e22e>noiseStrength</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseWarpShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;noiseStrength&#39;</span>, <span style=color:#a6e22e>noiseStrength</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godraysIntensity</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createSlider</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.01</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godraysIntensity</span>.<span style=color:#a6e22e>position</span>(<span style=color:#a6e22e>width</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>120</span>, <span style=color:#ae81ff>60</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godraysIntensity</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;width&#39;</span>, <span style=color:#e6db74>&#39;80px&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godraysIntensity</span>.<span style=color:#a6e22e>input</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>godraysShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;godraysIntensity&#39;</span>, <span style=color:#a6e22e>godraysIntensity</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godraysShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;godraysIntensity&#39;</span>, <span style=color:#a6e22e>godraysIntensity</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>image_pg</span>.<span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>image_pg</span>.<span style=color:#a6e22e>textureMode</span>(<span style=color:#a6e22e>NORMAL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>image_pg</span>.<span style=color:#a6e22e>shader</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>image_pg</span>.<span style=color:#a6e22e>image</span>(<span style=color:#a6e22e>imageTexture</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>height</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseWarp_pg</span>.<span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>noiseWarpShader</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseWarpShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;image&#39;</span>, <span style=color:#a6e22e>image_pg</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseWarpShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;resolution&#39;</span>, [<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>]);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noiseWarp_pg</span>.<span style=color:#a6e22e>rect</span>(<span style=color:#f92672>-</span><span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>height</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godrays_pg</span>.<span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>godraysShader</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godraysShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;image&#39;</span>, <span style=color:#a6e22e>noiseWarp_pg</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godraysShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;resolution&#39;</span>, [<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>]);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>godrays_pg</span>.<span style=color:#a6e22e>rect</span>(<span style=color:#f92672>-</span><span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>height</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Display final result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>image</span>(<span style=color:#a6e22e>godrays_pg</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><details><summary>NoiseWarp Shader</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#75715e>#ifdef GL_ES</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>sampler2D</span> image;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> resolution;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> noiseScale;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> noiseStrength;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>varying</span> <span style=color:#66d9ef>vec2</span> vTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2D Random</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> random(<span style=color:#66d9ef>vec2</span> p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> fract(sin(dot(p, <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>12.9898</span>, <span style=color:#ae81ff>78.233</span>))) <span style=color:#f92672>*</span> <span style=color:#ae81ff>43758.5453</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec2</span> uv <span style=color:#f92672>=</span> vTexCoord.xy;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec2</span> p <span style=color:#f92672>=</span> uv <span style=color:#f92672>*</span> resolution.xy <span style=color:#f92672>/</span> noiseScale;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> distortion <span style=color:#f92672>=</span> noiseStrength <span style=color:#f92672>*</span> (random(p) <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec2</span> distortedUV <span style=color:#f92672>=</span> uv <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(distortion);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec4</span> color <span style=color:#f92672>=</span> texture2D(image, distortedUV);
</span></span><span style=display:flex><span>  gl_FragColor <span style=color:#f92672>=</span> color;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><details><summary>GODrays Shader</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#75715e>#ifdef GL_ES</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>sampler2D</span> image;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> resolution;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> godraysIntensity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>varying</span> <span style=color:#66d9ef>vec2</span> vTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec2</span> uv <span style=color:#f92672>=</span> vTexCoord.xy;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec2</span> screenPos <span style=color:#f92672>=</span> uv <span style=color:#f92672>*</span> resolution;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec2</span> delta <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> resolution;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> weight <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec4</span> sum <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec4</span> currentColor <span style=color:#f92672>=</span> texture2D(image, uv);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>50</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    screenPos <span style=color:#f92672>-=</span> delta <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec4</span> sample <span style=color:#f92672>=</span> texture2D(image, screenPos);
</span></span><span style=display:flex><span>    sample <span style=color:#f92672>*=</span> weight;
</span></span><span style=display:flex><span>    sum <span style=color:#f92672>+=</span> sample;
</span></span><span style=display:flex><span>    weight <span style=color:#f92672>*=</span> godraysIntensity;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec4</span> godrayColor <span style=color:#f92672>=</span> sum <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.05</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec4</span> finalColor <span style=color:#f92672>=</span> mix(currentColor, godrayColor, godraysIntensity);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  gl_FragColor <span style=color:#f92672>=</span> finalColor;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h2 id=difucultades>Difucultades
<a class=anchor href=#difucultades>#</a></h2><p>El funcionamiento del programa se ve entorpecido por las políticas de CORS (Cross-Origin Resource Sharing), las cuales no permiten cargar los recursos citados en el código correctamente, junto con otros errores de p5.js que no ha sido posible resolver hasta el momento, pero se encuentra en revisión.</p><blockquote class="book-hint info"><a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a></blockquote><img src=showcase/content/sketches/shaders/postmalone/qunundrum.png alt=eeo width=500 height=600></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/8797f931cd57e8c97a7c8fcfe275a4c1508b0e35 title='Last modified by Rod | June 20, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 20, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#exercise>Exercise</a></li><li><a href=#god-rays-shader>God Rays Shader</a></li><li><a href=#noise-warp-shader>Noise Warp Shader</a><ul><li><a href=#controles>Controles</a></li></ul></li><li><a href=#difucultades>Difucultades</a></li></ul></li></ul></nav></div></aside></main></body></html>